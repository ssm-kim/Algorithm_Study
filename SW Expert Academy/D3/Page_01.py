import sys
sys.stdin = open('./public_input.txt', 'r')

'''
    SWEA D3 정렬조건
        - 정답율순, Python
        - 1페이지 단위 ( 10문제 )
      * 너무 쉬운 문제는 Pass

    풀이방법
        1. 문제 이해하기
            - input, output 특징 확인, input size N (시간복잡도 계산)
            - 제약조건 확인 (시간복잡도 제한 체크 및 알고리즘 선택) 및 예상할 수 있는 오류 파악

        2. 접근 방법
            2-1. 직관적으로 생각하기
                - 보통 완전탐색으로 시작
                - 문제 상황을 단순화/극한화하여 생각하기         
            2-2. 자료구조와 알고리즘 활용
            3-3. 메모리 사용
                - 시간복잡도를 줄이기 위해 사용하는 방법
                - 대표적으로 해시테이블 (딕셔너리)

        3. 코드 설계
        4. 코드 구현
'''

# 12368. 24시간
'''
    문제 이해 및 접근방법
        - 하루는 24시간이며, 자정에서 시작 자정에서 끝이다. 예를 들어, 오후 8시  ->  20시
        - 자정을 표기하는 유일한 방법은 0시뿐이다.
'''

# tc = int(input())
# for t in range(1, tc + 1):
#     a, b = map(int, input().split())
#     curTime = a+b
#     if curTime >= 24:
#         curTime -= 24

#     print('#{} {}'.format(t, curTime))
        
# ----------------------------------------------------------------------

# 3431. 준환이의 운동관리
'''
    문제 이해 및 접근방법
        - 적절한 몸을 유지하기 위하여 1주일에 L분 이상 U분 이하의 운동을 해야한다.
        - 이번주는 x분만큼 운동을 했다.
        - 제한되어 있는 시간을 넘은 운동을 한 것인지, 그것이 아니라면
          추가로 몇 분 더 운동을 해야 제한을 맞출 수 있는지 출력해라.
      * 필요한 양보가 더 많은 운동을 하고 있다면 -1 출력
'''

# tc = int(input())
# for t in range(1, tc + 1):
#     l, u, x = map(int, input().split())
#     answer = 0
#     if x < l:
#         answer = l-x
#     elif x > u:
#         answer = -1
    
#     print('#{} {}'.format(t, answer))

# ----------------------------------------------------------------------

# 13218. 조별과제
'''
    문제 이해 및 접근방법
'''
# tc = int(input())
# for t in range(1, tc + 1):
#     n = int(input())
#     print('#{} {}'.format(t, n//3))

# ----------------------------------------------------------------------

# 10505. 소득 불균형
'''
    문제 이해 및 접근방법
        - n명의 사람의 소득이 주어졌을 때 이 중 평균 이하의 소득을 가진 사람들의 수를 출력
'''
# tc = int(input())
# for t in range(1, tc + 1):
#     n = int(input())
#     income = list(map(int, input().split()))
#     cnt, avg = 0, sum(income)/n

#     for i in income:
#         if avg >= i:
#             cnt += 1

#     print('#{} {}'.format(t, cnt))

# ----------------------------------------------------------------------

# 4406. 모음이 보이지 않는 사람
'''
    문제 이해 및 접근방법
        - 알파벳에서 모음은 ‘a’, ‘e’, ‘i’, ‘o’, ‘u’의 다섯가지로
          예를 들어 “congratulation”이라는 단어를 당신이 보게 되면 “cngrtltn”으로 인식
'''
# tc = int(input())
# for t in range(1, tc + 1):
#     s = input()
#     answer = ''
#     for i in s:
#         if i not in ['a', 'e', 'i', 'o', 'u']:
#             answer += i
#     print('#{} {}'.format(t, answer))

# ----------------------------------------------------------------------

# 15941. 평행사변형
'''
    문제 이해 및 접근방법
        - 정수 N이 주어질 때, 모든 변의 길이가 N인 가장 넓은 평행사변형의 넓이를 출력
'''
# tc = int(input())
# for t in range(1, tc + 1):
#     n = int(input())
#     print('#{} {}'.format(t, n**2))

# ----------------------------------------------------------------------

# 12221. 구구단2
'''
    문제 이해 및 접근방법
        - 1 이상 9 이하의 자연수 두개를 곱셈가능하지만
          10 이상의 자연수는 곱셈하는 방법을 몰라서 -1를 출력한다.
'''
# tc = int(input())
# for t in range(1, tc + 1):
#     a, b = map(int, input().split())
#     answer = -1
#     if a < 10 and b < 10:
#         answer = a * b
#     print('#{} {}'.format(t, answer))

# ----------------------------------------------------------------------

# 1289. 원재의 메모리 복구하기
'''
    문제 이해 및 접근방법
        - 메모리 bit중 하나를 골라 0인지 1인지 결정하면 해당 값이 메모리의 끝까지 덮어씌우는 것
        - 예를 들어 지금 메모리 값이 0100이고, 3번째 bit를 골라 1로 설정하면 0111이 된다.
        - 원래 상태가 주어질 때 초기화 상태 (모든 bit가 0) 에서 원래 상태로 돌아가는데
          최소 몇 번이나 고쳐야 하는지 계산해라.
'''
# tc = int(input())
# for t in range(1, tc + 1):
#     memory = list(input())
#     cnt = 0
#     for s in range(len(memory)):
#         if memory[s] == '1':
#             for i in range(s, len(memory)):
#                 if memory[i] == '1':
#                     memory[i] = '0'
#                 else:
#                     memory[i] = '1'
#             cnt += 1
            
#     print('#{} {}'.format(t, cnt))

# ----------------------------------------------------------------------

# 11688. Calkin-Wilf tree 1  >  Pass
'''
    문제 이해 및 접근방법
        - 트리의 루트는 1/1 을 나타낸다.
        - 트리의 각 노드는 왼쪽 자식과 오른쪽 자식을 가지는데 어떤 노드가 a/b 를 나타내고 있다면
          왼쪽 자식은 a/a+b 를 오른쪽 자식은 a+b/b
        - 루트 노드에서부터, 자식을 따라 내려간 방향이 순서대로 주어질 때,
          마지막에 위치한 노드가 어떤 유리수를 나타내는지 구하라.
'''
# tc = int(input())
# for t in range(1, tc + 1):
#     state = input()
#     left, right = 1, 1
#     for i in state:
#         if i == 'L':
#             right += left
#         if i == 'R':
#             left += right

#     print('#{} {} {}'.format(t, left, right))
    
 
# ----------------------------------------------------------------------

# 1217.[S/W 문제해결 기본] 4일차 - 거듭 제곱
'''
    문제 이해 및 접근방법
'''
# tc = 10
# for t in range(1, tc + 1):
#     t = int(input())
#     n, m = map(int, input().split())
#     print('#', end='')
#     print(t, n**m)